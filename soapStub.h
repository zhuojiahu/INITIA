/* soapStub.h
   Generated by gSOAP 2.8.25 from Demo_soap.h

gSOAP XML Web services tools
Copyright (C) 2000-2015, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#ifndef soapStub_H
#define soapStub_H
#include "stdsoap2.h"
#if GSOAP_VERSION != 20825
# error "GSOAP VERSION 20825 MISMATCH IN GENERATED CODE VERSUS LIBRARY CODE: PLEASE REINSTALL PACKAGE"
#endif


/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Classes, Structs, and Unions                                               *
 *                                                                            *
\******************************************************************************/

struct ns__CameraInfo;	// Demo_soap.h:12
struct S_ArrayOfCameraInfo;	// Demo_soap.h:19
struct S_CameraInfo;	// Demo_soap.h:25
struct ns__ErrorTypeInfo;	// Demo_soap.h:32
struct S_ArrayOfErrorTypeInfo;	// Demo_soap.h:38
struct S_ErrorTypeInfo;	// Demo_soap.h:44
struct ns__StationInfo;	// Demo_soap.h:52
struct S_ArrayOfStationInfo;	// Demo_soap.h:59
struct S_StationInfo;	// Demo_soap.h:65
struct ns__Detectinfo;	// Demo_soap.h:71
struct ns__getInfo;	// Demo_soap.h:84

/* Demo_soap.h:12 */
#ifndef SOAP_TYPE_ns__CameraInfo
#define SOAP_TYPE_ns__CameraInfo (10)
/* ns:CameraInfo complex type: */
struct ns__CameraInfo
{
public:
	char *sCameraLabel;	/* optional element of XSD type xsd:string */
	int nCheckCount;	/* required element of XSD type xsd:int */
	int nKickCount;	/* required element of XSD type xsd:int */
public:
	int soap_type() const { return 10; } /* = unique type id SOAP_TYPE_ns__CameraInfo */
	         ns__CameraInfo();
	virtual ~ns__CameraInfo() { }
};
#endif

/* Demo_soap.h:19 */
#ifndef SOAP_TYPE_S_ArrayOfCameraInfo
#define SOAP_TYPE_S_ArrayOfCameraInfo (11)
/* SOAP encoded array of ns:CameraInfo schema type: */
struct S_ArrayOfCameraInfo
{
public:
	struct ns__CameraInfo **__ptr;
	int __size;
public:
	int soap_type() const { return 11; } /* = unique type id SOAP_TYPE_S_ArrayOfCameraInfo */
	         S_ArrayOfCameraInfo();
	virtual ~S_ArrayOfCameraInfo() { }
};
#endif

/* Demo_soap.h:25 */
#ifndef SOAP_TYPE_S_CameraInfo
#define SOAP_TYPE_S_CameraInfo (15)
/* S-CameraInfo complex type: */
struct S_CameraInfo
{
public:
	int nCameraCount;	/* required element of XSD type xsd:int */
	struct S_ArrayOfCameraInfo sCameraInfoArray;	/* required element of XSD type ArrayOfCameraInfo */
public:
	int soap_type() const { return 15; } /* = unique type id SOAP_TYPE_S_CameraInfo */
	         S_CameraInfo();
	virtual ~S_CameraInfo() { }
};
#endif

/* Demo_soap.h:32 */
#ifndef SOAP_TYPE_ns__ErrorTypeInfo
#define SOAP_TYPE_ns__ErrorTypeInfo (18)
/* ns:ErrorTypeInfo complex type: */
struct ns__ErrorTypeInfo
{
public:
	char *sErrorTypeName;	/* optional element of XSD type xsd:string */
	int nErrorTypeClass;	/* required element of XSD type xsd:int */
	int nErrorTypeKickCount;	/* required element of XSD type xsd:int */
public:
	int soap_type() const { return 18; } /* = unique type id SOAP_TYPE_ns__ErrorTypeInfo */
	         ns__ErrorTypeInfo();
	virtual ~ns__ErrorTypeInfo() { }
};
#endif

/* Demo_soap.h:38 */
#ifndef SOAP_TYPE_S_ArrayOfErrorTypeInfo
#define SOAP_TYPE_S_ArrayOfErrorTypeInfo (19)
/* SOAP encoded array of ns:ErrorTypeInfo schema type: */
struct S_ArrayOfErrorTypeInfo
{
public:
	struct ns__ErrorTypeInfo **__ptr;
	int __size;
public:
	int soap_type() const { return 19; } /* = unique type id SOAP_TYPE_S_ArrayOfErrorTypeInfo */
	         S_ArrayOfErrorTypeInfo();
	virtual ~S_ArrayOfErrorTypeInfo() { }
};
#endif

/* Demo_soap.h:44 */
#ifndef SOAP_TYPE_S_ErrorTypeInfo
#define SOAP_TYPE_S_ErrorTypeInfo (23)
/* S-ErrorTypeInfo complex type: */
struct S_ErrorTypeInfo
{
public:
	int nErrorTypeCount;	/* required element of XSD type xsd:int */
	struct S_ArrayOfErrorTypeInfo sErrorTypeInfoArray;	/* required element of XSD type ArrayOfErrorTypeInfo */
public:
	int soap_type() const { return 23; } /* = unique type id SOAP_TYPE_S_ErrorTypeInfo */
	         S_ErrorTypeInfo();
	virtual ~S_ErrorTypeInfo() { }
};
#endif

/* Demo_soap.h:52 */
#ifndef SOAP_TYPE_ns__StationInfo
#define SOAP_TYPE_ns__StationInfo (26)
/* ns:StationInfo complex type: */
struct ns__StationInfo
{
public:
	char *sStationLabel;	/* optional element of XSD type xsd:string */
	int nStationCheckCount;	/* required element of XSD type xsd:int */
	int nStationKickCount;	/* required element of XSD type xsd:int */
public:
	int soap_type() const { return 26; } /* = unique type id SOAP_TYPE_ns__StationInfo */
	         ns__StationInfo();
	virtual ~ns__StationInfo() { }
};
#endif

/* Demo_soap.h:59 */
#ifndef SOAP_TYPE_S_ArrayOfStationInfo
#define SOAP_TYPE_S_ArrayOfStationInfo (27)
/* SOAP encoded array of ns:StationInfo schema type: */
struct S_ArrayOfStationInfo
{
public:
	struct ns__StationInfo **__ptr;
	int __size;
public:
	int soap_type() const { return 27; } /* = unique type id SOAP_TYPE_S_ArrayOfStationInfo */
	         S_ArrayOfStationInfo();
	virtual ~S_ArrayOfStationInfo() { }
};
#endif

/* Demo_soap.h:65 */
#ifndef SOAP_TYPE_S_StationInfo
#define SOAP_TYPE_S_StationInfo (31)
/* S-StationInfo complex type: */
struct S_StationInfo
{
public:
	int nStationCount;	/* required element of XSD type xsd:int */
	struct S_ArrayOfStationInfo sStationInfoArray;	/* required element of XSD type ArrayOfStationInfo */
public:
	int soap_type() const { return 31; } /* = unique type id SOAP_TYPE_S_StationInfo */
	         S_StationInfo();
	virtual ~S_StationInfo() { }
};
#endif

/* Demo_soap.h:71 */
#ifndef SOAP_TYPE_ns__Detectinfo
#define SOAP_TYPE_ns__Detectinfo (34)
/* ns:Detectinfo complex type: */
struct ns__Detectinfo
{
public:
	long nMouldNumber;	/* SOAP 1.2 RPC return element (when namespace qualified) */	/* required element of XSD type xsd:int */
	char *sMouldID;	/* optional element of XSD type xsd:string */
	long nCheckCount;	/* required element of XSD type xsd:int */
	long nKickCount;	/* required element of XSD type xsd:int */
	struct S_CameraInfo sCameraInfo;	/* required element of XSD type xsd-CameraInfo */
	struct S_ErrorTypeInfo sErrorTypeInfo;	/* required element of XSD type xsd-ErrorTypeInfo */
	struct S_StationInfo sStationInfo;	/* required element of XSD type xsd-StationInfo */
	long nReserveRes1;	/* required element of XSD type xsd:int */
	long nReserveRes2;	/* required element of XSD type xsd:int */
	long nReserveRes3;	/* required element of XSD type xsd:int */
public:
	int soap_type() const { return 34; } /* = unique type id SOAP_TYPE_ns__Detectinfo */
	         ns__Detectinfo();
	virtual ~ns__Detectinfo() { }
};
#endif

/* Demo_soap.h:84 */
#ifndef SOAP_TYPE_ns__getInfo
#define SOAP_TYPE_ns__getInfo (37)
/* ns:getInfo complex type: */
struct ns__getInfo
{
public:
	int nOrder;	/* required element of XSD type xsd:int */
	int nReserveReq;	/* required element of XSD type xsd:int */
public:
	int soap_type() const { return 37; } /* = unique type id SOAP_TYPE_ns__getInfo */
	         ns__getInfo();
	virtual ~ns__getInfo() { }
};
#endif

/* Demo_soap.h:0 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (38)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	int soap_type() const { return 38; } /* = unique type id SOAP_TYPE_SOAP_ENV__Header */
	         SOAP_ENV__Header();
	virtual ~SOAP_ENV__Header() { }
};
#endif
#endif

/* Demo_soap.h:0 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (39)
/* Type SOAP_ENV__Code is a recursive data type (in)directly referencing itself through its (base) class members */
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of XSD type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of XSD type SOAP-ENV:Code */
public:
	int soap_type() const { return 39; } /* = unique type id SOAP_TYPE_SOAP_ENV__Code */
	         SOAP_ENV__Code();
	virtual ~SOAP_ENV__Code() { }
};
#endif
#endif

/* Demo_soap.h:0 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (41)
/* SOAP-ENV:Detail complex type: */
struct SOAP_ENV__Detail
{
public:
	char *__any;
	int __type;	/* any type of element <fault> (defined below)
	   WARNING: do not create a cyclic data structure graph throught this element unless SOAP encoding or SOAP_XML_GRAPH are used for id-ref serialization */
	void *fault;	/* transient (not serialized) */
public:
	int soap_type() const { return 41; } /* = unique type id SOAP_TYPE_SOAP_ENV__Detail */
	         SOAP_ENV__Detail();
	virtual ~SOAP_ENV__Detail() { }
};
#endif
#endif

/* Demo_soap.h:0 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (44)
/* SOAP-ENV:Reason complex type: */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of XSD type xsd:string */
public:
	int soap_type() const { return 44; } /* = unique type id SOAP_TYPE_SOAP_ENV__Reason */
	         SOAP_ENV__Reason();
	virtual ~SOAP_ENV__Reason() { }
};
#endif
#endif

/* Demo_soap.h:0 */
#ifndef WITH_NOGLOBAL
#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (45)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of XSD type xsd:QName */
	char *faultstring;	/* optional element of XSD type xsd:string */
	char *faultactor;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of XSD type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of XSD type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of XSD type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of XSD type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of XSD type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of XSD type SOAP-ENV:Detail */
public:
	int soap_type() const { return 45; } /* = unique type id SOAP_TYPE_SOAP_ENV__Fault */
	         SOAP_ENV__Fault();
	virtual ~SOAP_ENV__Fault() { }
};
#endif
#endif

/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/


/* Demo_soap.h:8 */
#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

/* Demo_soap.h:8 */
#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (6)
typedef char *_XML;
#endif

/* Demo_soap.h:8 */
#ifndef SOAP_TYPE_xsd__string
#define SOAP_TYPE_xsd__string (7)
typedef char *xsd__string;
#endif

/* Demo_soap.h:9 */
#ifndef SOAP_TYPE_xsd__int
#define SOAP_TYPE_xsd__int (9)
typedef long xsd__int;
#endif

/* Demo_soap.h:22 */
#ifndef SOAP_TYPE_ArrayOfCameraInfo
#define SOAP_TYPE_ArrayOfCameraInfo (14)
typedef struct S_ArrayOfCameraInfo ArrayOfCameraInfo;
#endif

/* Demo_soap.h:28 */
#ifndef SOAP_TYPE_CameraInfo
#define SOAP_TYPE_CameraInfo (16)
typedef struct S_CameraInfo CameraInfo;
#endif

/* Demo_soap.h:29 */
#ifndef SOAP_TYPE_xsd_CameraInfo
#define SOAP_TYPE_xsd_CameraInfo (17)
typedef CameraInfo xsd_CameraInfo;
#endif

/* Demo_soap.h:41 */
#ifndef SOAP_TYPE_ArrayOfErrorTypeInfo
#define SOAP_TYPE_ArrayOfErrorTypeInfo (22)
typedef struct S_ArrayOfErrorTypeInfo ArrayOfErrorTypeInfo;
#endif

/* Demo_soap.h:47 */
#ifndef SOAP_TYPE_ErrorTypeInfo
#define SOAP_TYPE_ErrorTypeInfo (24)
typedef struct S_ErrorTypeInfo ErrorTypeInfo;
#endif

/* Demo_soap.h:48 */
#ifndef SOAP_TYPE_xsd_ErrorTypeInfo
#define SOAP_TYPE_xsd_ErrorTypeInfo (25)
typedef ErrorTypeInfo xsd_ErrorTypeInfo;
#endif

/* Demo_soap.h:62 */
#ifndef SOAP_TYPE_ArrayOfStationInfo
#define SOAP_TYPE_ArrayOfStationInfo (30)
typedef struct S_ArrayOfStationInfo ArrayOfStationInfo;
#endif

/* Demo_soap.h:68 */
#ifndef SOAP_TYPE_StationInfo
#define SOAP_TYPE_StationInfo (32)
typedef struct S_StationInfo StationInfo;
#endif

/* Demo_soap.h:69 */
#ifndef SOAP_TYPE_xsd_StationInfo
#define SOAP_TYPE_xsd_StationInfo (33)
typedef StationInfo xsd_StationInfo;
#endif

/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Server-Side Operations                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 ns__getInfo(struct soap*, int nOrder, int nReserveReq, struct ns__Detectinfo *buf_out);

/******************************************************************************\
 *                                                                            *
 * Server-Side Skeletons to Invoke Service Operations                         *
 *                                                                            *
\******************************************************************************/

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve(struct soap*);

extern "C" SOAP_FMAC5 int SOAP_FMAC6 soap_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_ns__getInfo(struct soap*);

/******************************************************************************\
 *                                                                            *
 * Client-Side Call Stubs                                                     *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call_ns__getInfo(struct soap *soap, const char *soap_endpoint, const char *soap_action, int nOrder, int nReserveReq, struct ns__Detectinfo *buf_out);

#endif

/* End of soapStub.h */
